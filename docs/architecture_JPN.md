## 2. コアコンセプト

### GUIとワーカースレッドの分離
自動撮影のような時間のかかるタスク中にUIがフリーズするのを防ぐため、メインアプリケーション(`main_app.py`)はPythonの`threading`モジュールを使用しています。GUIはメインスレッドで動作し、自動化ロジックは別のワーカースレッドで実行されます。

### 重い処理のためのプロセス分離
画像の結合は、CPUとメモリを極度に消費する処理です。アプリケーション全体がフリーズするのを避けるため、結合GUI(`stitcher_app.py`)は、コアとなる結合エンジン(`advanced_stitcher.py`)を`multiprocessing`を使って完全に別のプロセスで起動します。GUIとエンジン間の通信（進捗更新など）は`multiprocessing.Queue`を介して行われます。

### グローバル最適化 vs 逐次結合
単純な結合方法として、画像を一枚ずつ順番に繋げていくやり方がありますが、これでは「ドリフト」と呼ばれる誤差の蓄積が発生し、最終的に大きな歪みとなって現れます。AutoMapは、この問題を**グローバル最適化**によって回避します。まず全ての画像間の相対位置を計算し、その後、巨大な連立一次方程式(`scipy.sparse.linalg.lsqr`)を解くことで、全画像にとって最も矛盾の少ない最適な配置を一度に決定します。

### 巨大画像のためのメモリ管理
最終的に結合された画像は、数ギガバイトを超えることがあり、PCに搭載されたRAM容量をはるかに上回ります。この問題に対処するため、レンダリング処理では`numpy.memmap`を使用します。これは、ハードディスク上のファイルをメモリ上の巨大なNumPy配列であるかのように扱う技術です。全ての描画処理はRAMを介さずディスクに直接書き込まれるため、メモリ不足エラーを回避できます。

---

## 3. コンポーネント詳細

### `main_app.py`
- **責務:** アプリケーションのメインエントリーポイント、撮影用GUI、自動化ロジック。
- **主要クラス:**
    - `RegionSelector(tk.Toplevel)`: 半透明の全画面ウィンドウを表示し、ユーザーがマウスドラッグで画面領域を選択できるようにします。結果は`config['region']`に保存されます。
    - `Application(ttk.Frame)`: メインアプリケーションのクラス。
- **主要関数:**
    - `setup_widgets()`: タブ、ラベル、ボタンなど、TkinterのGUI全体を構築します。
    - `start_automation()`: 撮影プロセスを開始します。ユーザー入力を検証し、`automation_thread`を開始します。
    - `automation_thread()`: 撮影ロジックの中核。
        - ユーザーが対象のブラウザウィンドウにフォーカスを合わせる時間を与えるため、5秒のカウントダウンが含まれます。
        - `pyautogui.press()`を使用して、ジグザグ（蛇行）パターンで矢印キー操作をエミュレートします。
        - 各グリッド位置で`take_screenshot()`を呼び出します。
        - Windows環境では、`ctypes.windll.kernel32.SetThreadExecutionState`を呼び出し、長時間の撮影中にシステムがスリープするのを防ぎます。
    - `take_screenshot()`: 設定で定義された画面領域をキャプチャします。OpenCVを使い、キャプチャした画像が真っ白（例：ローディング画面）でないかをチェックし、もしそうであれば待機して再試行するメカニズムが含まれています。

### `stitcher_app.py`
- **責務:** 結合オプションを設定するためのGUIを提供し、結合プロセスを管理します。
- **主要クラス:**
    - `StitcherApp(tk.Toplevel)`: 結合ツールのGUIウィンドウ。
- **主要関数:**
    - `_create_..._widgets()`: GUIの各セクション（入出力、オプション、ステータス）を構築するためのメソッド群。
    - `start_stitching()`:
        - ユーザーが設定した全オプション（重なり率、閾値など）を収集・検証します。
        - `stitcher_worker_wrapper`関数を実行するための`multiprocessing.Process`を作成します。これがGUIのフリーズを防ぐ鍵です。
        - プロセスを開始し、`status_queue`のポーリング（定期的なチェック）を開始します。
    - `check_status()`: `multiprocessing.Queue`を定期的にチェックし、ワーカープロセスからのメッセージ（'progress', 'status', 'done', 'error'など）を受け取ってGUIを更新します。
    - `stitcher_worker_wrapper()`: 別のプロセスで実行される単純なラッパー関数。`AdvancedStitcher`をインスタンス化して`run()`メソッドを呼び出し、発生した例外をキャッチしてキューを介してメインGUIに返します。

### `advanced_stitcher.py` (エンジン部)
- **責務:** 全ての複雑な画像解析と合成処理を実行します。このファイルにはGUIコンポーネントは一切含まれません。
- **主要クラス:**
    - `AdvancedStitcher`: 全ての結合ロジックを含むメインクラス。
- **主要関数 (実行順):**
    - `__init__()`: パラメータを初期化し、全ての`Rxx_Cxx.png`ファイルを見つけ、グリッドサイズを決定し、OpenCVの特徴点検出器（ORB）をセットアップします。
    - `verify_grid()`: 想定されるグリッド内に不足している画像ファイルがないかチェックします。
    - `calculate_all_pairwise_matches()`: 隣接する全ての画像ペア（水平・垂直）をループ処理します。各ペアに対して以下を呼び出します。
        - `_match_template()`: 歪みの少ない画像間のオフセットを高速に特定する手法。
        - `_match_features()`: テンプレートマッチングが失敗した場合に使用する、より頑健な（ただし低速な）手法。ORB特徴点検出とRANSACアルゴリズムを利用します。
    - `estimate_initial_positions()`: 前のステップで見つかった水平・垂直オフセットの中央値に基づき、大まかなグリッドレイアウトを計算します。
    - `run_global_optimization()`: 配置アルゴリズムの心臓部。
        - 巨大な疎行列`A`とベクトル`b`を構築し、連立一次方程式(`Ax = b`)を表現します。各行は2画像間の望ましいオフセットを表します。
        - グリッドが過度に歪むのを防ぐための「正則化」制約を追加します（`initial_pos_weight`で制御）。
        - `scipy.sparse.linalg.lsqr`を用いてこの方程式系を解き、全画像に対するグローバルに最適な`(x, y)`座標を見つけます。
    - `render_final_image()`:
        - 最適化された座標に基づき、最終的なキャンバスの総サイズを計算します。
        - `np.memmap`を使い、ディスク上に2つの一時的なメモリマップトファイルを作成します（カラーデータ用(3ch)とマスク用(1ch)）。
        - 各画像をループ処理し、計算された最終座標にディスク上のキャンバスへと貼り付けていきます。
        - 最後に、マスクを基に画像の存在する領域（バウンディングボックス）を見つけ、キャンバスを切り抜いて最終的なPNGファイルとして保存します。

### `config_manager.py`
- **責務:** アプリケーション設定の永続化を管理します。
- **主要関数:**
    - `load_config()`: `config.json`を読み込みます。ファイルが存在しないか無効な場合、デフォルト値を返します。保存された設定とデフォルト値をマージすることで、新しい設定オプションが常に存在することを保証します。
    - `save_config()`: 与えられた設定の辞書を、人間が読みやすい形式で`config.json`に書き込みます。

### `utils.py`
- **責務:** 小さく、再利用可能なヘルパー関数を含みます。
- **主要関数:**
    - `open_folder_in_explorer()`: `sys.platform`でOSをチェックし、ネイティブのファイルエクスプローラー（Windowsのエクスプローラー、macOSのFinder、Linuxのxdg-open）でファイルパスを開くためのクロスプラットフォーム関数。
